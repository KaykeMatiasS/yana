{"version":3,"sources":["webpack://ApiMountClient/webpack/universalModuleDefinition","webpack://ApiMountClient/webpack/bootstrap","webpack://ApiMountClient/external \"react\"","webpack://ApiMountClient/./lib/sticky-scroll.ts","webpack://ApiMountClient/./lib/scroll.ts","webpack://ApiMountClient/./lib/reverse-infinite-scroll.ts","webpack://ApiMountClient/./index.ts","webpack://ApiMountClient/./lib/chat-scroll.ts","webpack://ApiMountClient/./lib/data-loader.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","useStickyScroll","targetRef","data","options","useState","enabled","setEnabled","sticky","setSticky","stickyRef","useRef","moveScrollToBottom","current","scrollTop","scrollHeight","useEffect","length","handleScroll","clientHeight","currentlyAtBottom","updateStuckToBottom","setScrollEventHandler","useScroll","scrollToBottom","enable","disable","scrollEventHandlerRef","handlerId","setHandlerId","handler","el","addEventListener","removeEventListener","fetching","storedScrollHeight","storedScrollTop","isFetching","setFetching","setFetched","getCurrentScrollHeight","getScrollTop","setScrollTop","offset","getStoredScrollHeight","storeCurrentScrollHeight","getStoredScrollTop","storeCurrentScrollTop","useReverseInfiniteScroll","loadMoreCb","loadMoreRef","useReverseInfiniteScrollOptions","scrollThresholdType","scrollThresholdValue","initialEnabled","checkMap","EScrollThresholdType","fraction","pixels","needMore","diff","updateLoadMoreCb","newLoadMoreCb","scrollThreshold","type","useChatScroll","reverseInfiniteScroll","disableReverseInfiniteScroll","enableReverseInfiniteScroll","reverseInfiniteScrollEnabled","stickyScroll","disableStickyScroll","enableStickyScroll","stickyScrollEnabled","useDataLoader","dataLoader","setData","args","argsRef","dataRef","resolveRef","beforeRender","chunk","promise","Promise","resolve"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ApiMountClient\"] = factory();\n\telse\n\t\troot[\"ApiMountClient\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = require(\"react\");","import {useState, useRef, useEffect} from 'react'\nimport {useScroll} from './scroll'\n\n/**\n * React hook for keeping HTML element scroll at the bottom when content updates (if it is already at the bottom).\n * @param targetRef Reference of scrollable HTML element.\n * @param data Array of some data items displayed in a scrollable HTML element. It should normally come from a state.\n */\nexport const useStickyScroll = (\n  targetRef: React.MutableRefObject<Element>,\n  data: any[],\n  options?: IUseStickyScrollOptions,\n): IUseStickyScrollResponse => {\n  const [enabled, setEnabled] = useState<boolean>(options?.enabled ?? true)\n  const [sticky, setSticky] = useState<boolean>(true)\n  const stickyRef = useRef(sticky)\n\n  const moveScrollToBottom = () => {\n    targetRef.current.scrollTop = targetRef.current.scrollHeight\n  }\n\n  useEffect(() => {\n    stickyRef.current = sticky\n\n    if (sticky) {\n      moveScrollToBottom()\n    }\n  }, [data.length, targetRef, sticky])\n\n  const updateStuckToBottom = () => {\n    const {scrollHeight, clientHeight, scrollTop} = targetRef.current\n    const currentlyAtBottom = scrollHeight === scrollTop + clientHeight\n\n    if (stickyRef.current && !currentlyAtBottom) {\n      setSticky(false)\n    } else if (!stickyRef.current && currentlyAtBottom) {\n      setSticky(true)\n    }\n  }\n\n  const handleScroll = () => {\n    updateStuckToBottom()\n  }\n\n  const {setScrollEventHandler} = useScroll(targetRef)\n\n  useEffect(() => {\n    if (enabled) {\n      setScrollEventHandler(handleScroll)\n    } else {\n      setScrollEventHandler(() => {\n        return\n      })\n    }\n  }, [enabled])\n\n  /**\n   * Scrolls to bottom.\n   */\n  const scrollToBottom = () => {\n    moveScrollToBottom()\n    setSticky(true)\n  }\n\n  /**\n   * Enables sticky scroll behavior.\n   */\n  const enable = () => setEnabled(true)\n\n  /**\n   * Disables sticky scroll behavior.\n   */\n  const disable = () => setEnabled(false)\n\n  return {\n    enabled,\n    sticky,\n    scrollToBottom,\n    enable,\n    disable,\n  }\n}\n\n/**\n * Accepted options for customizing useStickyScroll hook.\n */\nexport interface IUseStickyScrollOptions {\n  /**\n   * Defines whether sticky scroll behavior is enabled initially.\n   */\n  enabled?: boolean\n}\n\n/**\n * Flags and methods provided by useStickyScroll hook.\n */\nexport interface IUseStickyScrollResponse {\n  /**\n   * True when sticky scroll behavior is enabled.\n   */\n  enabled: boolean\n\n  /**\n   * True when scroll is stuck to the bottom of target element.\n   */\n  sticky: boolean\n\n  /**\n   * Scrolls to bottom of the target element.\n   */\n  scrollToBottom: () => void\n\n  /**\n   * Enables sticky scroll behavior.\n   */\n  enable: () => void\n\n  /**\n   * Disables sticky scroll behavior.\n   */\n  disable: () => void\n}\n","import {useEffect, useRef, useState} from 'react'\n\n/**\n * React hook for controlling scrollable HTML element.\n * @private\n * @param targetRef Reference of scrollable HTML element.\n */\nexport const useScroll = (\n  targetRef: React.MutableRefObject<Element>,\n): IUseScrollResponse => {\n  const scrollEventHandlerRef = useRef<EventListener>(() => {\n    return\n  })\n\n  const [handlerId, setHandlerId] = useState<number>(1)\n\n  const setScrollEventHandler = (handler: EventListener) => {\n    scrollEventHandlerRef.current = handler\n    setHandlerId(handlerId + 1)\n  }\n\n  useEffect(() => {\n    const handler = scrollEventHandlerRef.current\n    const el = targetRef.current\n\n    handler({} as Event)\n    el.addEventListener('scroll', handler)\n\n    return () => {\n      el.removeEventListener('scroll', handler)\n    }\n  }, [handlerId])\n\n  const fetching = useRef<boolean>(false)\n  const storedScrollHeight = useRef<number>(0)\n  const storedScrollTop = useRef<number>(0)\n\n  const isFetching = () => fetching.current\n\n  const setFetching = () => {\n    fetching.current = true\n  }\n\n  const setFetched = () => {\n    fetching.current = false\n  }\n\n  const getCurrentScrollHeight = () => targetRef.current.scrollHeight\n\n  const getScrollTop = () => targetRef.current.scrollTop\n\n  const setScrollTop = (offset: number) => {\n    targetRef.current.scrollTop = offset\n  }\n\n  const getStoredScrollHeight = () => storedScrollHeight.current\n\n  const storeCurrentScrollHeight = () => {\n    storedScrollHeight.current = targetRef.current.scrollHeight\n  }\n\n  const getStoredScrollTop = () => storedScrollTop.current\n\n  const storeCurrentScrollTop = () => {\n    storedScrollTop.current = targetRef.current.scrollTop\n  }\n\n  return {\n    isFetching,\n    setFetching,\n    setFetched,\n    getCurrentScrollHeight,\n    getScrollTop,\n    setScrollTop,\n    getStoredScrollHeight,\n    storeCurrentScrollHeight,\n    getStoredScrollTop,\n    storeCurrentScrollTop,\n    setScrollEventHandler,\n  }\n}\n\n/**\n * Scroll event handler.\n */\nexport type IScrollEventHandler = (event: Event) => void\n\n/**\n * Flags and methods provided by useScroll hook.\n */\nexport interface IUseScrollResponse {\n  /**\n   * Verifies whether target element is currently fetching data.\n   */\n  isFetching: () => boolean\n\n  /**\n   * Marks target element as currently fetching data.\n   */\n  setFetching: () => void\n\n  /**\n   * Marks target element as currently not fetching data.\n   */\n  setFetched: () => void\n\n  /**\n   * Gathers current scroll height for target element.\n   */\n  getCurrentScrollHeight: () => number\n\n  /**\n   * Gathers current scroll position of target element.\n   */\n  getScrollTop: () => number\n\n  /**\n   * Scrolls target element.\n   * @param offset Scroll position from the top.\n   */\n  setScrollTop: (offset: number) => void\n\n  /**\n   * Gathers last stored value of target element scroll height.\n   */\n  getStoredScrollHeight: () => number\n\n  /**\n   * Stores current scroll height of target element for later use.\n   */\n  storeCurrentScrollHeight: () => void\n\n  /**\n   * Gathers last stored value of target element scroll top offset.\n   */\n  getStoredScrollTop: () => number\n\n  /**\n   * Stores current scroll offset of target element for later use.\n   */\n  storeCurrentScrollTop: () => void\n\n  /**\n   * Overrides scroll event handler to a new one.\n   */\n  setScrollEventHandler: (newScrollHandler: IScrollEventHandler) => void\n}\n","import {useScroll} from './scroll'\nimport {useState, useEffect, useRef} from 'react'\n\n/**\n * React hook for enabling reverse infinite scroll on HTML container when scroll reaches top.\n * @private\n * @param targetRef Reference of scrollable HTML element.\n * @param loadMoreCb Callback for loading more data.\n * It is very important to ensure that this callback does not issue a request if end of data is reached. Otherwise target server might be spammed with requests.\n * @param options Additional options to customize hook behavior.\n */\nexport const useReverseInfiniteScroll = (\n  targetRef: React.MutableRefObject<Element>,\n  loadMoreCb: ILoadMoreCb,\n  options?: IUseReverseInfiniteScrollOptions,\n): IUseReverseInfiniteScrollResponse => {\n  const loadMoreRef = useRef<ILoadMoreCb>(loadMoreCb)\n\n  const {\n    scrollThresholdType,\n    scrollThresholdValue,\n    enabled: initialEnabled,\n  } = useReverseInfiniteScrollOptions(options)\n\n  const [enabled, setEnabled] = useState(initialEnabled)\n\n  const {\n    setScrollEventHandler,\n    getCurrentScrollHeight,\n    getStoredScrollHeight,\n    getStoredScrollTop,\n    isFetching,\n    setFetched,\n    setFetching,\n    getScrollTop,\n    setScrollTop,\n    storeCurrentScrollHeight,\n    storeCurrentScrollTop,\n  } = useScroll(targetRef)\n\n  const needMore = () => {\n    const checkMap = {\n      [EScrollThresholdType.fraction]: () =>\n        getScrollTop() <= getCurrentScrollHeight() * scrollThresholdValue,\n      [EScrollThresholdType.pixels]: () =>\n        getScrollTop() <= scrollThresholdValue,\n    }\n\n    return checkMap[scrollThresholdType]?.() ?? false\n  }\n\n  const handleScroll = async () => {\n    if (!isFetching() && needMore()) {\n      setFetching()\n\n      await loadMoreRef.current(() => {\n        storeCurrentScrollHeight()\n        storeCurrentScrollTop()\n      })\n\n      const diff = getCurrentScrollHeight() - getStoredScrollHeight()\n      setScrollTop(getStoredScrollTop() + diff)\n\n      setFetched()\n    }\n  }\n\n  useEffect(() => {\n    if (enabled) {\n      setScrollEventHandler(handleScroll)\n    } else {\n      setScrollEventHandler(() => {\n        return\n      })\n    }\n  }, [enabled])\n\n  const enable = () => setEnabled(true)\n\n  const disable = () => setEnabled(false)\n\n  const updateLoadMoreCb = (newLoadMoreCb: ILoadMoreCb) => {\n    loadMoreRef.current = newLoadMoreCb\n  }\n\n  return {enable, disable, updateLoadMoreCb, enabled}\n}\n\n/**\n * Handles default values for useReverseInfiniteScroll hook options.\n * @private\n * @param options Additional options to customize hook behavior.\n */\nconst useReverseInfiniteScrollOptions = (\n  options: IUseReverseInfiniteScrollOptions,\n) => {\n  const scrollThresholdType =\n    options?.scrollThreshold?.type ?? EScrollThresholdType.fraction\n\n  const scrollThresholdValue =\n    options?.scrollThreshold?.value ??\n    scrollThresholdType === EScrollThresholdType.fraction\n      ? 0.2\n      : 1000\n\n  const enabled = options?.enabled ?? true\n\n  return {scrollThresholdType, scrollThresholdValue, enabled}\n}\n\n/**\n * Callback which would be called every time scroll is detected close to the top of container.\n * @param beforeRender - callback which should be called AFTER additional data is gathered but BEFORE any state is updated which is used for re-render.\n * @returns Promise which is resolved AFTER DOM is updated with additional data.\n */\nexport type ILoadMoreCb = (beforeRender: IBeforeRenderCb) => Promise<any>\n\n/**\n * Callback which should be called AFTER additional data is gathered but BEFORE any state is updated which is used for re-render.\n */\nexport type IBeforeRenderCb = () => void\n\n/**\n * Accepted options for customizing useReverseInfiniteScroll hook.\n */\nexport interface IUseReverseInfiniteScrollOptions {\n  /**\n   * Defines how close to the top user needs to scroll in order to invoke gathering of additional data.\n   */\n  scrollThreshold?: IScrollThreshold\n\n  /**\n   * Defines whether infinite scroll behavior is enabled initially.\n   */\n  enabled?: boolean\n}\n\n/**\n * Defines how close to the top user needs to scroll in order to invoke gathering of additional data.\n */\nexport interface IScrollThreshold {\n  /**\n   * Defines how threshold is calculated.\n   */\n  type?: EScrollThresholdType\n\n  /**\n   * Threshold value.\n   */\n  value?: number\n}\n\n/**\n * Defines how threshold is calculated.\n */\nexport enum EScrollThresholdType {\n  /**\n   * Fraction of content height left to the top (for example 0.2).\n   */\n  fraction,\n\n  /**\n   * Distance to top in pixels.\n   */\n  pixels,\n}\n\n/**\n * Flags and methods provided by useReverseInfiniteScroll hook.\n */\nexport interface IUseReverseInfiniteScrollResponse {\n  /**\n   * Indicates whether reverse infinite scroll behavior is enabled.\n   */\n  enabled: boolean\n\n  /**\n   * Enables reverse infinite scroll behavior.\n   */\n  enable: () => void\n\n  /**\n   * Disables reverse infinite scroll behavior.\n   */\n  disable: () => void\n\n  /**\n   * Overrides callback for loading more data with a new one.\n   */\n  updateLoadMoreCb: (newLoadMoreCb: ILoadMoreCb) => void\n}\n","export * from './lib/chat-scroll'\nexport * from './lib/sticky-scroll'\nexport * from './lib/data-loader'\n\nexport {\n  IBeforeRenderCb,\n  ILoadMoreCb,\n  IScrollThreshold,\n  IUseReverseInfiniteScrollOptions,\n  IUseReverseInfiniteScrollResponse,\n  EScrollThresholdType,\n} from './lib/reverse-infinite-scroll'\n\nexport {IScrollEventHandler, IUseScrollResponse} from './lib/scroll'\n","import {\n  IUseReverseInfiniteScrollOptions,\n  ILoadMoreCb,\n} from './reverse-infinite-scroll'\nimport {IUseStickyScrollOptions, useStickyScroll} from './sticky-scroll'\nimport {useReverseInfiniteScroll} from './reverse-infinite-scroll'\n\n/**\n * React hook for making HTML element scroll behaved like chat.\n * If scroll is at the bottom - it would stay there when new content is added.\n * Infinite scroll behavior would kick in when scrolling up.\n * @param targetRef Reference of scrollable HTML element.\n * @param data Array of some data items displayed in a scrollable HTML element. It should normally come from a state.\n * @param loadMoreCb Callback for loading more data.\n * It is very important to ensure that this callback does not issue a request if end of data is reached. Otherwise target server might be spammed with requests.\n * @param options Additional options to customize hook behavior.\n */\nexport const useChatScroll = (\n  targetRef: React.MutableRefObject<Element>,\n  data: any[],\n  loadMoreCb: ILoadMoreCb,\n  options?: IUseChatScrollOptions,\n): IUseChatScrollReturn => {\n  const {\n    disable: disableReverseInfiniteScroll,\n    enable: enableReverseInfiniteScroll,\n    enabled: reverseInfiniteScrollEnabled,\n    updateLoadMoreCb,\n  } = useReverseInfiniteScroll(\n    targetRef,\n    loadMoreCb,\n    options?.reverseInfiniteScroll ?? {},\n  )\n\n  const {\n    disable: disableStickyScroll,\n    enable: enableStickyScroll,\n    enabled: stickyScrollEnabled,\n    scrollToBottom,\n    sticky,\n  } = useStickyScroll(targetRef, data, options?.stickyScroll ?? {})\n\n  return {\n    reverseInfiniteScrollEnabled,\n    stickyScrollEnabled,\n    enableReverseInfiniteScroll,\n    disableReverseInfiniteScroll,\n    enableStickyScroll,\n    disableStickyScroll,\n    sticky,\n    scrollToBottom,\n    updateLoadMoreCb,\n  }\n}\n\n/**\n * Options for customizing behavior of useChatScroll hook.\n */\nexport interface IUseChatScrollOptions {\n  /**\n   * Options for reverse infinite scroll behavior.\n   */\n  reverseInfiniteScroll: IUseReverseInfiniteScrollOptions\n\n  /**\n   * Options for sticky scroll behavior.\n   */\n  stickyScroll: IUseStickyScrollOptions\n}\n\n/**\n * Flags and methods provided by useChatScroll hook.\n */\nexport interface IUseChatScrollReturn {\n  /**\n   * True when scroll is stuck to the bottom of target element.\n   */\n  sticky: boolean\n\n  /**\n   * Indicates whether reverse infinite scroll behavior is enabled.\n   */\n  reverseInfiniteScrollEnabled: boolean\n\n  /**\n   * True when sticky scroll behavior is enabled.\n   */\n  stickyScrollEnabled: boolean\n\n  /**\n   * Enables reverse infinite scroll behavior.\n   */\n  enableReverseInfiniteScroll: () => void\n\n  /**\n   * Disables reverse infinite scroll behavior.\n   */\n  disableReverseInfiniteScroll: () => void\n\n  /**\n   * Enables sticky scroll behavior.\n   */\n  enableStickyScroll: () => void\n\n  /**\n   * Disables sticky scroll behavior.\n   */\n  disableStickyScroll: () => void\n\n  /**\n   * Scrolls to bottom of the target element.\n   */\n  scrollToBottom: () => void\n\n  /**\n   * Overrides callback for loading more data with a new one.\n   */\n  updateLoadMoreCb: (newLoadMoreCb: ILoadMoreCb) => void\n}\n","import {ILoadMoreCb, IBeforeRenderCb} from '../index'\nimport {useEffect, useRef} from 'react'\n\n/**\n * React hook which creates a usable data loader for useInfiniteScroll hook.\n * It is only useful if new data is always added to the beginning of the array.\n * Should one need a different behavior or better optimization techniques - custom implementation would be needed.\n * @param dataLoader Data loader function to be converted into compatible callback for useDataLoader.\n * @param data Data to be shown in a scrollable HTML element.\n * @param setData Method for setting data into state.\n * @param args Array of arguments to be passed to data loader\n */\nexport const useDataLoader = (\n  dataLoader: IDataLoaderCb,\n  data: any[],\n  setData: ISetDataCb,\n  args: any[] = [],\n): ILoadMoreCb => {\n  const argsRef = useRef(args)\n  const dataRef = useRef(data)\n  const resolveRef = useRef(null)\n\n  useEffect(() => {\n    dataRef.current = data\n  }, [data, data.length])\n\n  useEffect(() => {\n    argsRef.current = [...args]\n  }, [...args])\n\n  const loader = async (beforeRender: IBeforeRenderCb) => {\n    const chunk = await dataLoader(...argsRef.current)\n    beforeRender()\n\n    const promise = new Promise(resolve => {\n      resolveRef.current = resolve\n    })\n\n    setData([...chunk, ...dataRef.current])\n    return promise\n  }\n\n  useEffect(() => {\n    if (resolveRef.current) {\n      resolveRef.current()\n      resolveRef.current = null\n    }\n  }, [data])\n\n  return loader\n}\n\n/**\n * Callback for loading additional data for scrollable HTML element.\n * Arguments for this function are passed as second argument of useDataLoader hook.\n */\nexport type IDataLoaderCb = (...args: any[]) => any\n\n/**\n * Method used for setting new data into state.\n */\nexport type ISetDataCb = (data: any[]) => void\n"],"sourceRoot":""}